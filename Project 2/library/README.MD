SIFS PROJECT FUNCTIONS

遵循官方顺序，本项目将会依照以下顺序开发。


mkdir.c
本功能的目的是实现在文件系统中创建新文件夹，根据文件从上到下的读写，我们需要做的事是首先修改 bitmap 就是记录文件系统各块信息的 char 数组，找到第一个空闲的块，记下对应的序号，并将其标识符改为 SIFS_DIR，然后我们需要修改 ~~第一个 block 即根目录信息~~ 新建文件夹的父目录的 block 信息（根据 Path 读取），修改 修改时间 子项目个数 以及 在 entries 数组中增加这个新的文件夹，然后再在对应的 空闲的 block 中写一个新的 SIFS_DIRBLOCK 结构体，记下名字和时间之后其他的内容都是 0，然后关闭文件就完成了。

dirinfo.c
本功能可以参考 sifs_dirinfo.c 进行实现，我们需要接受 DIFS 文件名，文件夹的路径名，以及返回的 String 数组，nentries, modified 三个值的指针。 
所以实现的方法是，首先尝试以只读的方式打开文件，如果出现异常即退出。之后跳过文件开头的 第一快和第二块，之后直接对所有的 block 进行循环，只检查是文件夹的 block，直到找到我们需要的 block，然后把对应的数据写入指针指向的地址，之后关闭文件。

rmdir.c
本功能的目的是删除一个空文件夹，首先尝试以读写的方式打开文件，如果出现异常即退出。之后跳过文件开头的前两块，然后按照上面 dirinfo 的模式找到本文件夹，如果文件夹里还有其他文件则报错并退出（如果规则是这样的），记录下对应的块号，之后清空本快，然后回到第二块 bitmap 将本块的标识符改为空，之后遍历 block 遇到 文件夹就检查其中的 entries 有没有指向这个文件夹，如果有就删除，全部遍历完之后关闭文件。
2019-10-10 3:00 pm 更新
尝试是否可以正常读写打开文件，然后使用 pathmatch 检查是否为合法路径，如果不是则退出。 之后检查需要删除的块的 bitmap 是否为文件夹 如果不是则退出。 然后将 bitmap 的这个块标记为 u
之后找到父目录，读取 然后删除对应的这个 entry 然后 nentries-- 然后将这个块写入文件 之后将这个块清零 然后将这个块写入文件中要删除的块的位置。
10 月 10 日前弄完 上面三个文件夹的功能后再考虑文件。

writefile.c
本功能需要读取文件并写入到 volume，首先尝试以读写的方式打开文件，如果出现异常即退出。然后首先检查路径是否正确。并记录下父目录地的 ID，读取文件开头的前两块，检查父目录是否可以放下新的 entry。然后检查文件的 md5，之后 loop 所有的文件块查看文件是否已经有了
如果没有 并找到第一个没有使用的 block 并记录下 ID 这将会是新文件块，并且使用文件大小除以单块大小 计算需要几个块，然后检查起始块+1（文件头）+文件需要块是否大于等于块数，如果大于即返回储存空间不足。 然后开始做文件头 写入所有的信息之后将本块写入文件 然后更改 bitmap 记录
然后开始写入文件 因为文件已经全部都在内存里了 所以直接在该块开头从数据指针中写入 size 大小的文件就可以了。 
然后在 bitmap中 文件块+1到 文件+1+块数-1 （小于文件+1+块数） 写入 data 块
如果有的话记下这个文件的块号，并且更新 modified 和 filenames[nfiles] 且 nfiles ++
现在文件块和文件数据就处理完毕了，记下号码之后 找到父目录块，修改修改时间以及新增一个 entries 然后 nentries++  然后目录块写入文件
关闭文件并返回 0


SIFS_writefile() needs to be provided with the data and length of that data or the new file to 
be written.  You'd typically allocate memory to store the to-be-saved file entire contents, and 
provide that to SIFS_writefile().

readfile.c
fileinfo.c
rmfile.c



附加功能
defrag.c
清理磁盘碎片的功能。
首先尝试以读写的方式打开文件，如果出现异常即退出。之后读取文件开头的前两块，然后进入无限循环。
在循环中首先做一个 for loop 从 bitmap 的最后一块开始循环 按理说应该全部都是空格 直到遇到第一块不是空格的内容 意味着进入到内容 此时记录下（进入内容 =1）
然后继续向前循环直到头部 如果再次遇到空格 就记下当前的块号（碎片结束块号 = i） 然后在向前循环 直到重新遇到有内容的块 （碎片开始 = i+1) 如果循环结束
如果碎片结束编号已经被记录 那么 碎片开始 = 0 如果碎片结束没有被记录 那就是没有碎片 中断无限循环 跳出 while 并关闭文件
在循环中需要执行的是 bitmap 从 碎片开始到（文件长度-碎片开始） bitmap[i] = bitmap[i+碎片量]
之后两个文件指针分别指向 碎片开始的地址 和碎片结束的地址  从结束的地址拿一个块 然后写入碎片开始的地址 共执行（最后一个块号-碎片结束的块号 次）
之后关闭文件

更新 每次将所有文件提前之后 需要遍历所有的block 找出所有的文件夹块  然后读取所有的 entries 如果 entries 的 block ID 大于等于 FragBegin 那么就要减去 fraglen

lastname.c
从 mkdir 中拿出来的 用于取得 pathname 中 除了任何前置路径的 真正的文件名（夹）名的功能

更新日志 

Project 2 4.0 2019-10-09 23:20:42
迄今为止 mkdir dirinfo 和 pathmatch 基本的功能已经实现
也没有发现什么致命 bug 明天需要完成 rmdir 的开发 并修复一些已知 bug
1. mkdir 现在会接受不存在的路径 
    比如 /abc/ 目录是空的 但是 执行 mkdir /abc/ab/a 其实 ab 的路径查找是失败的 
    但 pathmatch 寻址时依然会返回 /abc/ 作为父目录的路径，结果就会导致创建 /abc/a/ 文件夹
    解决方案是修改 PathMatch mode 2 的流程，当出现 /abc/ab/a 的父目录查找，如果 /abc/ab/ 不存在需要直接返回 -1 

其他的暂时没有发现错误信息


Project 2 4.9 2019-10-10 16:26
完成了 rmdir 的功能
并且写了新的 test 程序 可以根据不同的参数调用不同的功能 已知bug 如下
1. rmdir 现在接受根目录 
    这样会清除第一个块 现在需要修改不接受删除根目录

Project 2 4.9.1 2019-10-10 17:02
更新了 mkdir 和 pathmatch 不再接受不存在的路径 
当 pathmatch 需要求一个父目录不存在的路径的目录时返回-1 已知bug 如下
2. rmdir 完成删除之后会 Segmentation fault: 11 

Project 2 5.0 2019-10-10 19:30
修复了上述 bug 现在开始写 file

Project 2 5.1 2019-10-11 00:04:54
经过讨论后意识到磁盘碎片的可能性 写了新的 defrag 程序 之后发现了 
只是单纯的消除碎片会导致所有文件夹的 entries 号没有变 这样是不行的 还需要继续修改

Project 2 5.2 2019-10-11 01:03:57
修复了 5.1 的bug 
并修复了 mkdir 接收同名文件夹 即如果是存在的 还会再创建

Project 2 5.3 2019-10-11 23:15:06
通过阅读文档得到的一些 bug
1.  mkdir 新建文件和目录时应该注意 pathname 的长度 加上\0 不可以超过 32 个字符 (已修正)
2.  mkdir 新建文件和目录应该检查父目录是否可以放下新的 entry (已修正)
3.  mkdir 新建文件和目录应该检查磁盘是否已满（没有空闲块）(其实我发现并没有这个问题)
修复了 mkdir 的上述 bug 然后得到了新的 lastname 功能 并且写好了 writefile  暂时还没有测试

Project 2 5.5 2019-10-12 01:11:55
修复了 writefile 接收同名文件的问题
但现在的 bug 是同样的内容每次得到的 MD5 不同 
以及文件写入是空白的(解决方案是把 data 的内容先写入内存 之后从内存写入文件